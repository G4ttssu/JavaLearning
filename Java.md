Целые числа
byte - 1 байт - 128 до 127
short - 2 байта -32768 до 32767
int - 4 байта  -2147483648 до 2147483647
long - 8 байт  –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807

Числа с палвающей точкой
double - 8 байт `±4.9*10-324` до `±1.8*10308`
float - 4 байта от `-3.4*1038` до `3.4*1038`

таблица char  - UTF 16 [Таблица символов Юникода (Unicode)](http://foxtools.ru/Unicode#%D0%90)
для функции printf
Кроме спецификатора %d мы можем использовать еще ряд спецификаторов для других типов данных:

-   %x: для вывода шестнадцатеричных чисел
-   %f: для вывода чисел с плавающей точкой
-   %e: для вывода чисел в экспоненциальной форме, например, `1.3e+01`
-   %c: для вывода одиночного символa
-   %s: для вывода строковых значений

При выводе чисел с плавающей точкой мы можем указать количество знаков после запятой, для этого используем спецификатор на `%.2f`, где `.2` указывает, что после запятой будет два знака.

Класс Scanner имеет еще ряд методов, которые позволяют получить введенные пользователем значения:

-   next(): считывает введенную строку до первого пробела 
-   nextLine(): считывает всю введенную строку
-   nextInt(): считывает введенное число int    
-   nextDouble(): считывает введенное число double    
-   nextBoolean(): считывает значение boolean    
-   nextByte(): считывает введенное число byte    
-   nextFloat(): считывает введенное число float    
-   nextShort(): считывает введенное число short

### Приоритет операций

При работе с операциями важно понимать их приоритет, который можно описать следующей таблицей:

expr++ expr--

++expr --expr +expr -expr ~ !

* / %

+ -

<< >> >>>

< > <= >= instanceof

== !=

&

^

|

&&

||

? : (тернарный оператор)

= += -= *= /= %= &= ^= |= <<= >>= >>>= (операторы присваивания)

Чем выше оператор в этой таблице, тем больше его приоритет. При этом скобки повышают приоритет операции, используемой в выражении.

Расширяющие автоматические преобразования представлены следующими цепочками:

byte -> short -> int -> long

int -> double

short -> float -> double

char -> int

Если в операциях участвуют данные типа char, то они преобразуются в int:

`int d ='a'+5;`
`System.out.println(d);// 102`

Также следует отметить, что чтобы вызвать в методе main другие методы, которые определены в одном классе с методом main, они должны иметь модификатор `static`.

Конструкция try..catch также может иметь блок `finally`. Однако этот блок необязательный, и его можно при обработке исключений опускать. Блок `finally` выполняется в любом случае, возникло ли исключение в блоке try или нет:

Модификаторы:
-   public: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.
    
-   private: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.
    
-   protected: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах
    
-   Модификатор по умолчанию. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

Статические члены - static
Стоит учитывать, что вызов статического инициализатора производится после загрузки класса и фактически до создания самого первого объекта класса.
При использовании статических методов надо учитывать ограничения: в статических методах мы можем вызывать только другие статические методы и использовать только статические переменные. Вообще методы определяются как статические, когда методы не затрагиют состояние объекта, то есть его нестатические поля и константы, и для вызова метода нет смысла создавать экземпляр класса.

Объекты классов, как и данные примитивных типов, могут передаваться в методы. Однако в данном случае есть одна особенность - при передаче объектов в качестве значения передается копия ссылки на область в памяти, где расположен этот объект.

Классы могут быть вложенными (nested), то есть могут быть определены внури других классов. Частным случаем вложенных классов являются внутренние классы (inner class). Внутренний класс имеет доступ ко всем полям внешнего класса, в том числе закрытым с помощью модификатора private. Аналогично внешний класс имеет доступ ко всем членам внутреннего класса, в том числе к полям и методам с модификатором private.
Если в базовом классе определены конструкторы, то в конструкторе производного классы необходимо вызвать один из конструкторов базового класса с помощью ключевого слова super. При этом вызов конструктора базового класса должен идти в самом начале в конструкторе производного класса.
При переопределении метода он должен иметь уровень доступа не меньше, чем уровень доступа в базовом класса. С помощью ключевого слова super мы также можем обратиться к реализации методов базового класса.Хотя наследование очень интересный и эффективный механизм, но в некоторых ситуациях его применение может быть нежелательным. И в этом случае можно запретить наследование с помощью ключевого слова final. С методами также работает. При вызове переопределенного метода виртуальная машина динамически находит и вызывает именно ту версию метода, которая определена в подклассе. Данный процесс еще называется dynamic method lookup или динамический поиск метода или динамическая диспетчеризация методов.
Все методы интерфейса не имеют модификаторов доступа, но фактически по умолчанию доступ public, так как цель интерфейса - определение функционала для реализации его классом. Поэтому весь функционал должен быть открыт для реализации.

Enum - перечисляемый тип
При работе с объектами классов надо учитывать, что они все представляют ссылочные типы, то есть указывают на какой-то объект, расположенный в памяти.

Следует учитывать, что мы не можем наследовать запись record от других классов. Также нельзя наследовать классы от records. Однако классы record могут реализовать интерфейсы. Кроме того, классы record не могут быть абстрактными.

 record нельзя явным образом определять нестатические поля и инициализаторы. Но можно определять статические переменные и инициализаторы, также как статические и нестатические методы:
 Методы известных объектов - ссылки на источники
 Объекты String являются неизменяемыми, поэтому все операции, которые изменяют строки, фактически приводят к созданию новой строки, что сказывается на производительности приложения.