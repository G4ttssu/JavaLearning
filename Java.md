# Синтаксис Java
[Источник](https://metanit.com/java/tutorial/). Информация будет постепенно обновляться и добавляться новая.
### Целые числа
byte - 1 байт - 128 до 127
short - 2 байта -32768 до 32767
int - 4 байта  -2147483648 до 2147483647
long - 8 байт  –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807

### Числа с палвающей точкой
double - 8 байт `±4.9*10-324` до `±1.8*10308`
float - 4 байта от `-3.4*1038` до `3.4*1038`

### Таблица символов формата char  - UTF 16 
[Таблица символов Юникода (Unicode)](http://foxtools.ru/Unicode#%D0%90)

###  Форматированный вывод
-   %d: для вывода десятичных чисел
-   %x: для вывода шестнадцатеричных чисел
-   %f: для вывода чисел с плавающей точкой
-   %e: для вывода чисел в экспоненциальной форме, например, 1.3e+01
-   %c: для вывода одиночного символa
-   %s: для вывода строковых значений

<details><summary>Пометка</summary>
	При выводе чисел с плавающей точкой мы можем указать количество знаков после запятой, для этого используем спецификатор на %.2f, где .2 указывает, что после запятой будет два знака.
</details>


### Приоритет операций
1. expr++ expr--
2. ++expr --expr +expr -expr ~ !
3. * / %
4. + -
5. << >> >>>
6. < > <= >= instanceof
7. == !=
8. &
9. ^
10. |
11. &&
12. ||
13. ? : (тернарный оператор)
14. = += -= *= /= %= &= ^= |= <<= >>= >>>= 

> Чем выше оператор, тем больше его приоритет. При этом скобки повышают приоритет операции, используемой в выражении.

### Автоматические преобразования типов
byte -> short -> int -> long

int -> double

short -> float -> double

char -> int

Если в операциях участвуют данные типа char, то они преобразуются в int:
``` java
int d ='a'+5;
System.out.println(d);// 102
```

### Обработка исключений
Конструкция try..catch также может иметь блок ==finally==. Однако этот блок необязательный, и его можно при обработке исключений опускать. Блок ==finally== выполняется в любом случае, возникло ли исключение в блоке try или нет:

### ООП
Модификаторы:
-   public: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.
-   private: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.
-   protected: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах.
-   Модификатор по умолчанию. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

### Статические члены *static*
Стоит учитывать, что вызов статического инициализатора производится после загрузки класса и фактически до создания самого первого объекта класса.
При использовании статических методов надо учитывать ограничения: в статических методах мы можем вызывать только другие статические методы и использовать только статические переменные. Вообще методы определяются как статические, когда методы не затрагиют состояние объекта, то есть его нестатические поля и константы, и для вызова метода нет смысла создавать экземпляр класса.

### Передача объектов в качестве аргумента
Объекты классов, как и данные примитивных типов, могут передаваться в методы. Однако в данном случае есть одна особенность - при передаче объектов в качестве значения передается копия ссылки на область в памяти, где расположен этот объект.

### Вложенные классы
Классы могут быть вложенными ==nested==, то есть могут быть определены внури других классов. Частным случаем вложенных классов являются внутренние классы ==inner class==. Внутренний класс имеет доступ ко всем полям внешнего класса, в том числе закрытым с помощью модификатора private. Аналогично внешний класс имеет доступ ко всем членам внутреннего класса, в том числе к полям и методам с модификатором private.
Если в базовом классе определены конструкторы, то в конструкторе производного классы необходимо вызвать один из конструкторов базового класса с помощью ключевого слова super. При этом вызов конструктора базового класса должен идти в самом начале в конструкторе производного класса.

### Наследование
При переопределении метода он должен иметь уровень доступа не меньше, чем уровень доступа в базовом класса. С помощью ключевого слова super мы также можем обратиться к реализации методов базового класса. Хотя наследование очень интересный и эффективный механизм, но в некоторых ситуациях его применение может быть нежелательным. И в этом случае можно запретить наследование с помощью ключевого слова ==final==. С методами также работает. При вызове переопределенного метода виртуальная машина динамически находит и вызывает именно ту версию метода, которая определена в подклассе. Данный процесс еще называется ==dynamic method lookup== или динамический поиск метода или динамическая диспетчеризация методов.

### Интерфейсы
Все методы интерфейса не имеют модификаторов доступа, но фактически по умолчанию доступ public, так как цель интерфейса - определение функционала для реализации его классом. Поэтому весь функционал должен быть открыт для реализации.

### Class Scanner 
-   next(): считывает введенную строку до первого пробела 
-   nextLine(): считывает всю введенную строку
-   nextInt(): считывает введенное число int    
-   nextDouble(): считывает введенное число double    
-   nextBoolean(): считывает значение boolean    
-   nextByte(): считывает введенное число byte    
-   nextFloat(): считывает введенное число float    
-   nextShort(): считывает введенное число short


### Enum - перечисляемый тип
При работе с объектами классов надо учитывать, что они все представляют ссылочные типы, то есть указывают на какой-то объект, расположенный в памяти.

### Record
Следует учитывать, что мы не можем наследовать запись record от других классов. Также нельзя наследовать классы от ==records==. Однако классы record могут реализовать интерфейсы. Кроме того, классы record не могут быть абстрактными. ==Record== нельзя явным образом определять нестатические поля и инициализаторы. Но можно определять статические переменные и инициализаторы, также как статические и нестатические методы:

### String
Объекты String являются неизменяемыми, поэтому все операции, которые изменяют строки, фактически приводят к созданию новой строки, что сказывается на производительности приложения.

### Потоки 
